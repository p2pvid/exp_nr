"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBuffer = exports.toString = void 0;
const threads_id_1 = require("@textile/threads-id");
const buffer_1 = require("buffer");
const varint_1 = __importDefault(require("varint"));
const protocols_1 = require("./protocols");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const Convert = require("multiaddr/src/convert");
function thread2buf(str) {
    // const buf = Buffer.from(str)
    const buf = threads_id_1.ThreadID.fromString(str).toBytes();
    const size = buffer_1.Buffer.from(varint_1.default.encode(buf.length));
    return buffer_1.Buffer.concat([size, buf]);
}
function buf2thread(buf) {
    const size = varint_1.default.decode(buf);
    buf = buf.slice(varint_1.default.decode.bytes);
    if (buf.length !== size) {
        throw new Error("inconsistent lengths");
    }
    return threads_id_1.ThreadID.fromBytes(buf).toString();
}
function toString(prt, buf) {
    const proto = protocols_1.protocols(prt);
    switch (proto.code) {
        case 406:
            return buf2thread(buf);
        default:
            return Convert.toString(prt, buf);
    }
}
exports.toString = toString;
function toBuffer(prt, str) {
    const proto = protocols_1.protocols(prt);
    switch (proto.code) {
        case 406:
            return thread2buf(str);
        default:
            return Convert.toBuffer(prt, str);
    }
}
exports.toBuffer = toBuffer;
//# sourceMappingURL=convert.js.map