{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import bs58 from \"bs58\"\nimport { Buffer } from \"buffer\"\nimport CID from \"cids\"\nimport varint from \"varint\"\nimport * as codec from \"./codec\"\nimport { Protocol, protocols } from \"./protocols\"\n\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Buffer, String or another Multiaddr instance\n * public key.\n * @class Multiaddr\n * @param {(String|Uint8Array|Multiaddr)} addr - If String or Buffer, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nclass Multiaddr {\n  public buffer: Buffer = Buffer.alloc(0)\n  constructor(addr: string | Multiaddr | Uint8Array) {\n    if (!(this instanceof Multiaddr)) {\n      return new Multiaddr(addr)\n    }\n\n    // default\n    if (addr == null) {\n      addr = \"\"\n    }\n\n    if (addr instanceof Uint8Array) {\n      addr = Buffer.from(addr)\n    }\n\n    if (addr instanceof Buffer) {\n      /**\n       * @type {Buffer} - The raw bytes representing this multiaddress\n       */\n      this.buffer = codec.fromBuffer(addr)\n    } else if (typeof addr === \"string\" || addr instanceof String) {\n      if (addr.length > 0 && addr.charAt(0) !== \"/\") {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      this.buffer = codec.fromString(addr as string)\n    } else if (\n      !(addr instanceof Uint8Array) &&\n      addr.buffer &&\n      addr.protos &&\n      addr.protoCodes\n    ) {\n      // Multiaddr\n      this.buffer = codec.fromBuffer(addr.buffer) // validate + copy buffer\n    } else {\n      throw new Error(\"addr must be a string, Uint8Array, or another Multiaddr\")\n    }\n  }\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   */\n  toString(): string {\n    return codec.bufferToString(this.buffer)\n  }\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   */\n  toJSON = this.toString\n\n  /**\n   * Returns Multiaddr as a convenient options object to be used with network.createConnection\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   */\n  toOptions(): any {\n    const opts: any = {}\n    const parsed = this.toString().split(\"/\")\n    opts.family = parsed[1] === \"ip4\" ? \"ipv4\" : \"ipv6\"\n    opts.host = parsed[2]\n    opts.transport = parsed[3]\n    opts.port = parseInt(parsed[4])\n    return opts\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n   */\n  inspect(): string {\n    return (\n      \"<Multiaddr \" +\n      this.buffer.toString(\"hex\") +\n      \" - \" +\n      codec.bufferToString(this.buffer) +\n      \">\"\n    )\n  }\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   */\n  protos(): Protocol[] {\n    return this.protoCodes().map((code) => Object.assign({}, protocols(code)))\n  }\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   */\n  protoCodes(): number[] {\n    const codes = []\n    const buf = this.buffer\n    let i = 0\n    while (i < buf.length) {\n      const code = varint.decode(buf, i)\n      const n = varint.decode.bytes\n\n      const p = protocols(code)\n      const size = codec.sizeForAddr(p, buf.slice(i + n))\n\n      i += size + n\n      codes.push(code)\n    }\n\n    return codes\n  }\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   */\n  protoNames(): (string | number)[] {\n    return this.protos().map((proto) => proto.name)\n  }\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   */\n  tuples(): (number | Buffer)[][] {\n    return codec.bufferToTuples(this.buffer)\n  }\n\n  /**\n   * Returns a tuple of string/number parts\n   *\n   * @example\n   * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n   */\n  stringTuples(): any[][] {\n    const t = codec.bufferToTuples(this.buffer)\n    return codec.tuplesToStringTuples(t)\n  }\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   */\n  encapsulate(addr: Multiaddr): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   */\n  decapsulate(addr: Multiaddr): Multiaddr {\n    const str = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(str)\n    if (i < 0) {\n      throw new Error(\n        \"Address \" + this + \" does not contain subaddress: \" + addr\n      )\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   */\n  decapsulateCode(code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(codec.tuplesToBuffer(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   */\n  getPeerId(): string | undefined {\n    let b58str: string | undefined\n    try {\n      const tuples = this.stringTuples().filter((tuple: any) => {\n        if (tuple[0] === protocols.names.ipfs.code) {\n          return true\n        }\n      })\n\n      // Get the last id\n      b58str = (tuples.pop() || [])[1]\n      // Get multihash, unwrap from CID if needed\n      b58str = bs58.encode(new CID(b58str || \"\").multihash)\n    } catch (e) {\n      b58str = undefined\n    }\n\n    return b58str\n  }\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   */\n  getPath(): string | null {\n    let path = null\n    try {\n      path = this.stringTuples().filter((tuple: any) => {\n        const proto = protocols(tuple[0])\n        if (proto.path) {\n          return true\n        }\n      })[0][1]\n    } catch (e) {\n      path = null\n    }\n\n    return path\n  }\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n   *\n   * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   */\n  equals(addr: Multiaddr): boolean {\n    return this.buffer.equals(addr.buffer)\n  }\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n   */\n  nodeAddress(): {\n    family: string | number\n    address: string\n    port: string | number\n  } {\n    const codes = this.protoCodes()\n    const names = this.protoNames()\n    const parts = this.toString().split(\"/\").slice(1)\n\n    if (parts.length < 4) {\n      throw new Error(\n        'multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".'\n      )\n    } else if (\n      codes[0] !== 4 &&\n      codes[0] !== 41 &&\n      codes[0] !== 54 &&\n      codes[0] !== 55\n    ) {\n      throw new Error(\n        `no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`\n      )\n    } else if (parts[2] !== \"tcp\" && parts[2] !== \"udp\") {\n      throw new Error(\n        `no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`\n      )\n    }\n\n    return {\n      family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n      address: parts[1], // ip addr\n      port: parseInt(parts[3]), // tcp or udp port\n    }\n  }\n\n  /**\n   * Creates a Multiaddr from a node-friendly address object\n   *\n   * @example\n   * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   */\n  static fromNodeAddress(\n    addr: {\n      family: string | number\n      address: string\n      port: string | number\n    },\n    transport: string\n  ): Multiaddr {\n    if (!addr) throw new Error(\"requires node address object\")\n    if (!transport) throw new Error(\"requires transport protocol\")\n    const ip = addr.family === \"IPv6\" ? \"ip6\" : \"ip4\"\n    return new Multiaddr(\n      \"/\" + [ip, addr.address, transport, addr.port].join(\"/\")\n    )\n  }\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n   * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n   * const mh3 = mh1.encapsulate(mh2)\n   * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   */\n  static isThinWaistAddress(addr: Multiaddr): boolean {\n    const protos = (addr || this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    return !(protos[1].code !== 6 && protos[1].code !== 273)\n  }\n\n  /**\n   * Object containing table, names and codes of all supported protocols.\n   * To get the protocol values from a Multiaddr, you can use\n   * [`.protos()`](#multiaddrprotos),\n   * [`.protoCodes()`](#multiaddrprotocodes) or\n   * [`.protoNames()`](#multiaddrprotonames)\n   */\n  static protocols = protocols\n\n  /**\n   * Returns if something is a Multiaddr that is a name\n   */\n  static isName(addr: Multiaddr): boolean {\n    if (!Multiaddr.isMultiaddr(addr)) {\n      return false\n    }\n\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable)\n  }\n\n  /**\n   * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n   */\n  static resolve(addr: Multiaddr): Promise<never> {\n    if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n      return Promise.reject(Error(\"not a valid name\"))\n    }\n\n    /*\n     * Needs more consideration from spec design:\n     *   - what to return\n     *   - how to achieve it in the browser?\n     */\n    return Promise.reject(new Error(\"not implemented yet\"))\n  }\n\n  static isMultiaddr(other: any): any {\n    return other\n  }\n}\n\nexport { Multiaddr }\n"]}